# Migrating the Explorers Backend to Firebase

This document outlines the plan to refactor the Explorers application, moving its data source from static, compiled-in Go files to a dynamic backend using Google Cloud Firestore. This is a foundational step towards enabling live editing, user-generated content, and real-time updates.

---

## 1. Goals

-   **Decouple Data:** Separate the map data (systems, paths) from the application binary.
-   **Enable Dynamic Updates:** Allow map data to be changed without recompiling and redeploying the application.
-   **Pave the Way for Editing:** Create the necessary backend infrastructure to support future features like creating/editing systems and paths directly in the application.

---

## 2. Firestore Data Model

We will use two top-level collections in our Firestore database:

1.  `systems`: Each document in this collection will represent a single star system or point of interest.
2.  `paths`: Each document will represent a path segment connecting two points.

### `systems` Collection

A document in this collection will map directly to our `model.System` struct. For example:

```json
// Document ID: Uure
{
  "name": "Uure",
  "description": "A bustling hub of trade and intrigue.",
  "col": 5,
  "row": 3,
  "has_planet": true
}
```

### `paths` Collection

A document here will map to the `data.PathSegment` struct.

```json
// Document ID: <auto-generated>
{
  "name": "Spiny Rat Trade Route",
  "description": "A well-established trade route...",
  "start_coord": [0, 1],
  "start_offset": [0, 0],
  "end_coord": [1, 1],
  "end_offset": [0, 0]
}
```

---

## 3. Go Application Refactoring

This is the most significant part of the work. We will introduce a new service to handle all communication with Firestore.

### Step 3.1: Dependencies and Build System

We will need to add the official Firebase Admin SDK for Go.

-   **`go.mod`:** Add the dependency.
    ```bash
    go get firebase.google.com/go/v4
    ```
-   **`BUILD.bazel`:** Update the `deps` for the `explorers` `go_binary` to include the new Firebase dependency.

### Step 3.2: Struct Tagging

To allow the Firebase SDK to easily marshal data between Firestore documents and our Go structs, we need to add `firestore` tags to our data models.

-   **`apps/explorers/model/model.go` (`System` struct):**
    ```go
    type System struct {
        Name        string `firestore:"name"`
        Description string `firestore:"description"`
        SysCol      int    `firestore:"col"`
        SysRow      int    `firestore:"row"`
        HasPlanet   bool   `firestore:"has_planet"`
    }
    ```
-   **`apps/explorers/data/pathdata.go` (`PathSegment` struct):**
    ```go
    type PathSegment struct {
        Name        string `firestore:"name"`
        Description string `firestore:"description"`
        StartCoord  [2]int `firestore:"start_coord"`
        StartOffset [2]int `firestore:"start_offset"`
        EndCoord    [2]int `firestore:"end_coord"`
        EndOffset   [2]int `firestore:"end_offset"`
    }
    ```

### Step 3.3: New Firebase Data Service

I will create a new package, `apps/explorers/dataservice`, to encapsulate all Firestore logic.

**`apps/explorers/dataservice/client.go`:**
```go
package dataservice

import (
    "context"
    "log"

    "cloud.google.com/go/firestore"
    firebase "firebase.google.com/go/v4"
    "github.com/cshabsin/thegrid/apps/explorers/data"
    "github.com/cshabsin/thegrid/apps/explorers/model"
    "google.golang.org/api/option"
)

// Client holds a connection to the Firestore database.
type Client struct {
    fs *firestore.Client
}

// NewClient creates a new client connected to Firestore.
// IMPORTANT: Credentials should be handled via environment variables
// (e.g., GOOGLE_APPLICATION_CREDENTIALS), not checked into code.
func NewClient(ctx context.Context) (*Client, error) {
    conf := &firebase.Config{ProjectID: "YOUR_PROJECT_ID"} // Replace with your Project ID
    app, err := firebase.NewApp(ctx, conf)
    if err != nil {
        return nil, fmt.Errorf("error initializing app: %v", err)
    }

    client, err := app.Firestore(ctx)
    if err != nil {
        return nil, fmt.Errorf("error creating firestore client: %v", err)
    }
    return &Client{fs: client}, nil
}

// GetSystems retrieves all documents from the 'systems' collection.
func (c *Client) GetSystems(ctx context.Context) ([]*model.System, error) {
    var systems []*model.System
    iter := c.fs.Collection("systems").Documents(ctx)
    for {
        doc, err := iter.Next()
        if err == iterator.Done {
            break
        }
        if err != nil {
            return nil, err
        }
        var sys model.System
        if err := doc.DataTo(&sys); err != nil {
            return nil, err
        }
        systems = append(systems, &sys)
    }
    return systems, nil
}

// GetPaths retrieves all documents from the 'paths' collection.
func (c *Client) GetPaths(ctx context.Context) ([]data.PathSegment, error) {
    var paths []data.PathSegment
    iter := c.fs.Collection("paths").Documents(ctx)
    // ... (similar logic to GetSystems)
    return paths, nil
}

func (c *Client) Close() {
    c.fs.Close()
}
```

### Step 3.4: Update Main Application Logic

The `main` function in `apps/explorers/explorers.go` will be updated to use this new service.

-   The static `data` and `model` packages will no longer be the direct source of truth.
-   The `model.FromURL` call will be replaced with calls to our new `dataservice` client.

**`apps/explorers/explorers.go` (snippet):**
```go
func main() {
    // ... (initial setup)

    ctx := context.Background()
    dataSvc, err := dataservice.NewClient(ctx)
    if err != nil {
        log.Fatalf("Failed to create dataservice client: %v", err)
    }
    defer dataSvc.Close()

    systems, err := dataSvc.GetSystems(ctx)
    if err != nil {
        log.Fatalf("Failed to get systems: %v", err)
    }

    paths, err := dataSvc.GetPaths(ctx)
    if err != nil {
        log.Fatalf("Failed to get paths: %v", err)
    }

    // The rest of the rendering logic will now use the 'systems' and 'paths'
    // slices fetched from Firestore instead of the static data.
    // ...
}
```

---

## 4. Next Steps

Once this migration is complete and verified, we will be in an excellent position to:

1.  **Implement Editing:** Add functions to the `dataservice` like `UpdateSystem`, `CreatePath`, etc.
2.  **Add Authentication:** Use Firebase Authentication to secure the editing functions, allowing only authorized users to modify the map data.
3.  **Enable Real-time Updates:** Use Firestore's real-time listeners (`.onSnapshot`) to update the map for all connected clients instantly when data changes.
